<!-- puppet-polymer-client version: 0.0.0 | MIT License -->

<link rel="import" href="../polymer/polymer.html">
<!-- <link rel="import" href="iron-request.html"> -->

<!-- include PuppetJs with dependencies -->
<script src="../fast-json-patch/src/json-patch-duplex.js"></script>
<script src="../json-patch-queue/src/json-patch-queue.js"></script>
<script src="../json-patch-ot-agent/src/json-patch-ot-agent.js"></script>
<script src="../json-patch-ot/src/json-patch-ot.js"></script>
<script src="../PuppetJs/src/puppet.js"></script>
<script src="../PuppetJs/src/puppet-dom.js"></script>

<!--
The Polymer version of `puppet-client` element binds [PuppetJs](https://github.com/PuppetJs/PuppetJs) with [Polymer's template binding](https://www.polymer-project.org/1.0/docs/devguide/templates.html).
That keeps your Polymer app, or just `dom-bind` template in sync with any server-side
data-model using Puppet & [JSON Patch](https://tools.ietf.org/html/rfc6902) flow.

You get three-way data binding server - JS - HTML, kept in flawless sync.

    <puppet-client
        obj="{{model}}"></puppet-client>


It establishes the PuppetJs connection when attached. All the changes made
in browser are sent to the server via WebSocket or HTTP, as
[JSON Patch](https://tools.ietf.org/html/rfc6902)es.
All the changes from server are also received and propagated to your HTML.

@demo demo/index.html
-->

<script>
(function(){
    'use strict';


    Polymer({

        is: 'puppet-client',

        /**
         * Fired when patch gets applied
         *
         * @event patch-applied
         */
        /**
         * Fired when patch gets applied
         *
         * @event patchreceived
         */
        /**
         * Fired when patch gets applied
         *
         * @event patchsent
         */
        /**
         * Fired when patch gets applied
         *
         * @event socketstatechanged
         */
        /**
         * Fired when patch gets applied
         *
         * @event connectionerror
         */


        hostAttributes: {
            hidden: true
        },

        properties: {
            /**
             * The remote's URL
             */
            remoteUrl: {
                type: String
            },
            /**
             * Regular expression with local properties to ignore
             * @see [PuppetJS.ignoreAdd](https://github.com/PuppetJs/PuppetJs#ignoring-local-changes-ignoreadd).
             * Should be given in string format, like `"_.+"`.
             */
            ignoreAdd: {
                type: RegExp,
                value: /.*/
            },
            /**
             * Set to `false` to disable WebSocket (use HTTP)
             */
            useWebSocket: {
                type: Boolean,
                value: true
            },
            /**
             * Set to true to enable debugging mode
             */
            debug: {
                type: Boolean,
                value: false
            },
            /**
             * {JSONPointer} local version path, set to falsy do disable Versioned JSON Patch communication
             */
            localVersionPath: {
                type: String,
                value: '/_ver#c$'
            },
            /**
             * {JSONPointer} remote version path, set it to falsy to disable Double Versioned JSON Patch communication
             */
            remoteVersionPath: {
                type: String,
                value: '/_ver#s'
            },
            /**
             * `false` to disable OT
             */
            ot: {
                type: Boolean,
                value: true
            },
            /**
             * `true` to enable purist mode of OT
             */
            purity: {
                type: Boolean,
                value: false
            },
            /**
             *  DOM node to listen to (see [PuppetDOM listenTo attribute](https://github.com/PuppetJs/PuppetJs#puppetdom))
             */
            listenTo: {
                type: String
            },
            /**
             *  Interval in seconds between ping patches, `0` - disable ping patches
             */
            pingInterval: {
                type: Number,
                value: '60'
            },

            /**
             * Object that will be synced
             */
            obj: {
                type: Object,
                notify: true,
				value: function() {
                     return {};
                }
            },

            /**
             * Path to given obj
             */
            path: {
                type: String,
                value: '/'
            },


            // /**
            //  * If true, automatically performs an Ajax request when either `url` or
            //  * `params` changes.
            //  */
            // auto: {
            //     type: Boolean,
            //     value: false
            // },

        },

        /*observers: [
            '_objChanged(obj, obj.*)'
        ],*/

        created: function(){
            this.onPatchReceived = this.onPatchReceived.bind(this);
            this.onPatchSent = this.onPatchSent.bind(this);
            this.onSocketStateChanged = this.onSocketStateChanged.bind(this);
            this.onConnectionError = this.onConnectionError.bind(this);

        },
        /**
         * Creates an instance of Puppet according to given params, attaches it to .pupet property
         *
         */
        attached: function() {

            var whereToBind = this.getAttribute("ref");
            var listenTo = this.listenTo;
            var pingInterval = this.pingInterval / 1;
            var me = this;

            if (listenTo) {
                listenTo = typeof listenTo == "string" ? document.getElementById(listenTo) : listenTo;
            }
            function onDataReady(obj){
                /*
                // TODO tomalec: consider changing it in PuppetJS so it starts observing after this callback
                this.unobserve();
                // XXX: will do nothing, if this.obj was defined on attached callback!
                // as old obj === new obj :( recursiveExtend tricked us
                me.notifyPath('obj', obj);

                this.observe();
				*/
            }

            this.puppet = new PuppetDOM({
            // PuppetDOM.call(this,{
                // use server URL or window.location.href;
                remoteUrl: this.remoteUrl,
                pingInterval: pingInterval,
                listenTo: listenTo,
                obj:            this.obj,
                useWebSocket: this.useWebSocket,
                ignoreAdd: this.ignoreAdd,
                debug: this.debug,
				onRemoteChange: this._objChanged,
                callback: onDataReady,
                onDataReady: onDataReady,

                localVersionPath: this.localVersionPath,
                remoteVersionPath: this.remoteVersionPath,
                ot: this.ot,
                purity: this.purity,
                jsonpatch: {
                    apply: this.applyJSONPatch.bind(this),
                    observe: jsonpatch.observe.bind(this),
                    unobserve: jsonpatch.unobserve.bind(this),
                    validate: this.validateJSONPatch.bind(this)
                },
                callback: function () {
                    if (whereToBind) {
                        this.bindTo(whereToBind);
                    }
                }.bind(this)
            });
            // this.puppet.addEventListener('patch-applied', this.notifyChange);
        },
        bindTo: function(element){
            // use node id or node itself;
            element = typeof element == "string" ? document.getElementById( element ) : element;
            element.model = this.obj;
        },
        _objChanged: function(obj, changes){
            var templates = document.querySelectorAll("template[is=dom-bind], template[is=dom-repeat]");
            for (var i in templates) {
                if (templates.hasOwnProperty(i)) {
                    if (templates[i].model) {
                        //this is a template[is=dom-bind]
                        templates[i]._pathEffector("model", templates[i].model);
                    }
                    if (templates.hasOwnProperty(i) && templates[i].items) {
                        //this is a template[is=dom-repeat]
                        templates[i]._pathEffector("items", templates[i].items);
                    }
                }
            }
        },
        onPatchReceived: function(data, url, method) {
            console.log('onPatchReceived', arguments);
            // TODO: this JSON.parse is redundant
            // this.notifyChange(JSON.parse(data));
            this.fire("patchreceived", {
                data: data,
                url: url,
                method: method
            });
        },
        onPatchSent: function(data, url, method) {
            console.log('onPatchSent', arguments);
            this.fire("patchsent", {
                data: data,
                url: url,
                method: method
            });
        },
        onSocketStateChanged: function(state, url, data, code, reason) {
            console.log('onSocketStateChanged', arguments);
            this.fire("socketstatechanged", {
                state: state,
                url: url,
                data: data,
                statusCode: code,
                reason: reason
            });
        },
        onConnectionError: function(data, url, method) {
            console.log('onConnectionError', arguments);
            var eventDetail = {
                data: data,
                url: url,
                method: method,
                handled: false
            };


            this.fire("connectionerror", eventDetail);

            if (!eventDetail.handled) {
                alert("Connection error, please reload page!");
            }
        },
        applyJSONPatch: function(tree, sequence){
            this._beingSet = true;
            console.info('applyJSONPatch', tree, sequence);
            var operation, polymerPath;
            for(var operationNo = 0, len = sequence.length; operationNo < len; operationNo++){
			    operation = sequence[operationNo];

			    if (operation.path == "") {
			        //in case of root path, Polymer replaces the original obj, which detaches it from Puppet
			        var newSequence = [];
			        for (var prop in operation.value) {
				        if (operation.value.hasOwnProperty(prop)) {
					        newSequence.push({op: "add", path: "/" + prop, value: operation.value[prop]});
						}
					}
					this.applyJSONPatch(tree, newSequence);
					continue;
				}

                polymerPath = 'obj' + translateJSONPointerToPolymerPath(operation.path);

                if( operation.op === 'test'){
                    // we assume that jsonpatch covered it already
                } else if( operation.op === 'move' ||  operation.op === 'copy'){
                    console.warn("move, and copy operations are not supported yet.")
                } else {
                    // for add and remove we need to check whether it's an array or not
                    var lastSeparator = operation.path.lastIndexOf('/');
                    var name = operation.path.substr(lastSeparator + 1);
                    var parentsPolymerPath = 'obj' + translateJSONPointerToPolymerPath(operation.path.substr(0,lastSeparator));

                    var parent = this.get(parentsPolymerPath);
                    if(Array.isArray(parent) && (name === '-' || isNormalInteger(name))){
                        var addedCount = 0;
                        var removed = [];
                        switch(operation.op){
                            case 'add':
                                // JSONPatch push
                                if(name === '-'){
                                    name = parent.length;
                                }
                                this.splice(parentsPolymerPath, name, 0, operation.value);
                                // this.notifySplices(parentsPolymerPath, [{
                                //     index: name,
                                //     removed: [],
                                //     addedCount: 1,
                                //     object: parent,
                                //     type: 'splice'
                                // }]);
                                console.info('Add /splice in array is fergile, as Polymer requires something they call normalization, so splices to appear in index order, what is not guaranteed by this element.')

                                break;
                            case 'replace':

                                this.splice(parentsPolymerPath, name, 1, operation.value);
                                break;
                                // addedCount = 1;
                                // var col = Polymer.Collection.get(parent);
                                // removed = col.getItem('#'+name);
                            case 'remove':
                                this.splice(parentsPolymerPath, name, 1);
                                // this.notifySplices(parentsPolymerPath, [{
                                //     index: name,
                                //     removed: removed,
                                //     addedCount: addedCount,
                                //     object: parent,
                                //     type: 'splice'
                                // }]);
                                console.info('Remove is fergile, as Polymer requires something they call normalization, so splices to appear in index order, what is not guaranteed by this element.')
                                break;
                        }
                    } else {
                        switch(operation.op){
                            case 'add':
                            case 'replace':
                                this.set(polymerPath, operation.value);
                                // this.notifyPath(polymerPath, operation.value);
                                break;
                            case 'remove':
                                this.set(polymerPath, null);
                                this.set(polymerPath, undefined);
                                // this.notifyPath(polymerPath, undefined);
                                console.warn('Polymer does not support unsetting properties https://github.com/Polymer/polymer/issues/2565');
                                console.warn('remove is translated to JSON incompatible set to `undefined`, as there is no remove mathond in Polymer.')
                                break;
                        }
                    }
                }
            }
            this._beingSet = false;
            //    this.dispatchEvent(event);
            // FIXME tomalec: DRY, puppet does the same
            this.dispatchEvent(new CustomEvent("patch-applied", {bubbles: true, cancelable: true, detail: sequence}));
        },
        validateJSONPatch: function(){
            console.info('inherit  validateJSONPatch from fast-json-patch');
        },
        observeJSONPatch: function(obj, callback){
            this.puppetObserver = callback;
            console.log('attach Listeners');
            return callback;
        },
        unobserveJSONPatch: function(){
            console.log('detach listeners');
            // FIXME this is dummy as hell
            this.puppetObserver = noop;
        }


    });
    function noop(){}
    function translateJSONPointerToPolymerPath(pointer){
        return pointer.replace(/\//g, '.');
    }

    function translatePolymerPathToJSONPointer(pointer){
        return pointer.replace(/~/g, '~0')
                        .replace(/\//g,'~1')
                        .replace(/\./g, '/');
    }

    function isNormalInteger(str) {
        var n = ~~Number(str);
        return String(n) === str && n >= 0;
    }


    var _isArray;
    if (Array.isArray) {
        _isArray = Array.isArray;
    } else {
        _isArray = function (obj) {
            return obj.push && typeof obj.length === 'number';
        };
    }


  }());
</script>
